includes

 - At an #include (and include_next,import) directive, we need to record the
   full path of the included file, and the source range of the filename.
   (Can we say that the file is a symbol, then record a ref to it?)

Find more user-friendly symbol names than USRs.

 - Do USRs go away entirely?  Is there a one-to-one or a one-to-many
   relationship between a USR and a user-friendly name?  If USRs are still
   present, then will their existence make navigator behavior magical/opaque?

Template arguments

 - Instead of recording a std::vector<Foo*, std::allocator<Foo*>>, we can
   record one of:
    - std::vector
    - std::vector<Foo*>
   I'm not aware of a downside to omitting template arguments that match the
   default.  I'm not sure it's really feasible.  Omitting the template arguments
   entirely has the advantage of reducing the number of symbols at a single
   source point (but it doesn't solve the problem -- consider preprocessor
   usage).  It means that I could xref on std::vector::push_back to see all uses
   of that method regardless of the contained type.

Ref ranges

 - For refs, try to get range info (start+stop) rather than just a location.
   This is needed for C++ destructors because "~ Foo" is not an identifier, but
   we'd probably like the whole thing to be treated like one.  (Actually, can
   there be comments in there?)

Highlighting

 - For highlighting, we want to differentiate between kinds of symbols:
    - types
    - members
    - local variables

Bugs (bad ref kinds)

 - For "class A : T<A>" we record A as a Base-Class.  It should be something
   else, maybe just Reference.
 - See notes/misc for more.

Special buffers (scratch space, built-in macros)

 - I keep seeing references to "<scratch space>" and "<built-in>".  They ought
   to go away.  Maybe some of the scratch space references have something to
   do with the preprocessor and with the way the indexer deals with macros
   and source locations.

 - For "<built-in>" (and command-line -D/-U args?), the ideal fix probably goes
   like this.  We'd have a special table ("builtins") mapping USRs for built-in
   macro definitions to a string with the expanded tokens.  Then at some point,
   we'd read this table and turn it into a special buffer.  Something like this:
      /*built-in*/ FOO => 1
      /*built-in*/ FOO => 0
      /*cmd-line*/ FOO => 1
      /*cmd-line*/ FOO => undef
      /*built-in*/ #define BAR 1
      /*built-in*/ #define BAZ 1
   We could do this transformation right before writing the completed index
   file, or we could do in the navigator itself.  Each line in the special
   buffer implies one extra ref.  (I assume the values themselves don't refer
   to other macros, but I don't know that for sure.)  If the transformation is
   done at index time, then we can create the refs then, but we need to store
   the buffer in the index ("special-buffers" table, with one column mapping
   "<built-in>" to the content?).  If the transformation is done at run-time,
   then the navigator will have to augment the ref query to add in the built-in
   refs.

   DECISION: I think the transformation should be done at index-time so as to
   keep more C/C++-specific code out of the navigator.

----

For C++, include parameter type names to handle overloading:

std::vector::push_back(A*)

For symbols with internal linkage:

    basename.h/static_function
    basename.h/foo::<anon>::function

Templates: -- omit the template params entirely

    PROBLEM: What about function overloading?  Suppose there are two
    functions:
        int func(std::vector<int> &vi)
        int func(std::vector<double &vd)
    Would we represent both as this?
        func(std::vector&)

----

Problem at llvm/include/llvm/ADT/SmallVector.h, lines 273.
There is no ref on SmallVectorTemplateBase or value.

    class SmallVectorImpl : public SmallVectorTemplateBase<T, isPodLike<T>::value> {

----

New uint32_t encoding:

0xxxxxxx
10xxxxxx xxxxxxxx
110xxxxx xxxxxxxx xxxxxxxx
1110xxxx xxxxxxxx xxxxxxxx xxxxxxxx
1111000x xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx

This variable-length encoding ensures that a sequence of numbers has the same
order as its encoded byte-string (which is the concatenation of the VLE-encoded
numbers).

Each xxxxxxxx represents 255 values rather than 256, to avoid NUL bytes.  This
will require division to encode a number and multiplication to decode a number.

The encoding handles the values [0..2**32-1].  To encode zero without using a
NUL byte, one is added to the value before encoding it.

----

Calls to the clang::VarDecl(Kind, DeclContext, ...) ctor seem to be missing
from the refs info.  Also review whether calls to dtors are in the refs info.
This might be a difficult thing to fix -- a lot of these calls are implicit.
Image what happens with std::vector<SomeType> -- where are calls to
SomeType::~SomeType coming from?  Implicit conversions are probably related.

----

This is probably mentioned elsewhere, but record it here anyway.  The Curiously
Recurring Template Pattern appears repeatedly in LLVM+Clang, and the Derived
class appears as a Base-Class ref.  It should appear as just a Reference.
